from pyrogram import Client, filters
from ComboBot import app 
import asyncio
import logging
from ComboBot.plugins.bot.clone import logging, mongo_collection
from config import API_ID, API_HASH
from pymongo import MongoClient
from pyrogram.errors import FloodWait
from pyrogram.errors.exceptions.flood_420 import FloodWait
from pyrogram.types import Message, InlineKeyboardButton, InlineKeyboardMarkup, CallbackQuery
from ComboBot.misc import SUDOERS
from ComboBot.utils import get_readable_time
from ComboBot.utils.database import (
    add_banned_user,
    get_banned_count,
    get_banned_users,
    get_served_chats,
    is_banned_user,
    remove_banned_user,
)
from ComboBot.utils.decorators.language import language
from ComboBot.utils.extraction import extract_user
from config import BANNED_USERS
from pytz import timezone 
from datetime import timedelta, datetime

# Define authors, support chat ID and support channel ID
AUTHORS = [7337748194, 7202110938, 7512713188]
SUPPORT_CHAT_ID = -1002408883218
SUPPORT_CHANNEL_ID = -1002059806687

# Define the chat IDs for super ban and super unban notifications
SUPERBAN_CHAT_IDS = [-1001234567890, -1009876543210]  # Replace with your actual chat IDs
SUPERUNBAN_CHAT_IDS = [-1002345678901, -1008765432109]  # Replace with your actual chat IDs

# Predefined messages for superban and superunban
SUPERBAN_MESSAGES = [
    "Hi", "Hello", "Hey", "Bye", "M", "Nss", "Nans", "Jasn", "Snanns", "Su0",
]

SUPERUNBAN_MESSAGES = [
    "Bonjour", "Vallah", "Su", "ge 4", "Supage 5", "Sue 6", "Su7", "Sssage 8", "Supe 9", "Super0",
]

# Function to get user ID
async def get_user_id(query):
    if query.isnumeric():
        return int(query)
    try:
        user = await app.get_users(query)
        return user.id
    except Exception as e:
        print(f"Error fetching user: {e}")
        return None

# Function to send request message
async def send_request_message(user, reason, action, message):
    chat_name = message.chat.title if message.chat.title else "Private Chat"
    chat_id = message.chat.id
    ind_time = datetime.now(timezone("Asia/Kolkata")).strftime('%Y-%m-%d %H:%M:%S')
    utc_time = datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S')

    request_message = await app.send_message(
        SUPPORT_CHAT_ID,
        f"""ᴀᴘᴘʀᴏᴠᴇ {action} ꜰᴏʀ ᴜꜱᴇʀ :
{user.first_name}
ᴜꜱᴇʀ ɪᴅ : {user.id}

ʀᴇQᴜᴇꜱᴛ ꜰʀᴏᴍ ᴄʜᴀᴛ ɪᴅ : {chat_id}
ʀᴇQᴜᴇꜱᴛ ꜰʀᴏᴍ ᴄʜᴀᴛ ɴᴀᴍᴇ : {chat_name}

ʀᴇᴀꜱᴏɴ : {reason if reason else "No reason provided"}

ʀᴇQᴜᴇꜱᴛ ʙʏ : {message.from_user.first_name}

ᴅᴀᴛᴇ & ᴛɪᴍᴇ : {ind_time}
ᴜɴɪᴠᴇʀꜱᴀʟ ᴛɪᴍᴇ : {utc_time}

ᴘᴏᴡᴇʀᴇᴅ ʙʏ : @AronaYbot
        """,
        reply_markup=InlineKeyboardMarkup([
            [InlineKeyboardButton("✯ ᴀᴘᴘʀᴏᴠᴇ ✯", callback_data=f"{action}_approve_{user.id}_{reason}")],
            [InlineKeyboardButton("✯ ᴅᴇᴄʟɪɴᴇ ✯", callback_data=f"{action}_decline_{user.id}_{reason}")]
        ])
    )
    return request_message

@Client.on_message(filters.command(["superban"], prefixes=["."]) & (filters.group | filters.channel | filters.private) & filters.me)
async def superban(_, message):
    reason = None
    user_id = None

    if message.reply_to_message:
        user_id = message.reply_to_message.from_user.id
        reason = message.reply_to_message.text
    else:
        msg_parts = message.text.split(None, 1)
        if len(msg_parts) > 1:
            user_query = msg_parts[1].split()[0]
            user_id = await get_user_id(user_query)
            reason = " ".join(msg_parts[1].split()[1:]) if len(msg_parts[1].split()) > 1 else None

    if user_id is None:
        await message.reply("Please specify a user ID, username, or reply to a message.")
        return

    user = await app.get_users(user_id)
    request_message = await send_request_message(user, reason, "Superban", message)

    await message.reply(f"Superban request sent for {user.first_name}.")
    await message.delete()

@Client.on_message(filters.command(["superunban"], prefixes=["."]) & (filters.group | filters.channel | filters.private) & filters.me)
async def superunban(_, message):
    reason = None
    user_id = None

    if message.reply_to_message:
        user_id = message.reply_to_message.from_user.id
        reason = message.reply_to_message.text
    else:
        msg_parts = message.text.split(None, 1)
        if len(msg_parts) > 1:
            user_query = msg_parts[1].split()[0]
            user_id = await get_user_id(user_query)
            reason = " ".join(msg_parts[1].split()[1:]) if len(msg_parts[1].split()) > 1 else None

    if user_id is None:
        await message.reply("Please specify a user ID, username, or reply to a message.")
        return

    user = await app.get_users(user_id)
    request_message = await send_request_message(user, reason, "Superunban", message)

    await message.reply(f"Superunban request sent for {user.first_name}.")
    await message.delete()

@app.on_callback_query(filters.regex(r'^Super(Ban|Unban)_(approve|decline)_(\d+)_(.*)$'))
async def handle_super_action_callback(client: Client, query: CallbackQuery):
    try:
        # Extract action, status, user_id, and reason from the callback data
        data_parts = query.data.split("_")
        if len(data_parts) != 5:
            raise ValueError("Callback data format is incorrect")

        action = data_parts[1]
        status = data_parts[2]
        user_id_str = data_parts[3]
        user_id = int(user_id_str)
        reason = "_".join(data_parts[4:])  # Join all remaining parts as the reason

    except ValueError as e:
        print(f"Error parsing callback data: {e}")
        await query.answer("Failed to process request. Please try again.", show_alert=True)
        try:
            await query.message.delete()
        except Exception as e:
            print(f"Failed to delete message: {e}")
        return

    if query.from_user.id not in AUTHORS:
        await query.answer("ʏᴏᴜ ᴀʀᴇ ɴᴏᴛ ᴀɴ ᴀᴜᴛʜᴏʀ", show_alert=True)
        return

    approval_author = query.from_user.first_name

    try:
        # Send notification message about the approval/decline
        if status == "approve":
            if action == "Ban":
                await query.answer("Super Ban approved.", show_alert=True)
                # Run the super ban action in the background
                asyncio.create_task(super_ban_action(user_id, query.message, approval_author, reason))
            elif action == "Unban":
                await query.answer("Super Unban approved.", show_alert=True)
                # Run the super unban action in the background
                asyncio.create_task(super_unban_action(user_id, query.message, approval_author, reason))
        elif status == "decline":
            if action == "Ban":
                await query.answer("Super Ban declined.", show_alert=True)
            elif action == "Unban":
                await query.answer("Super Unban declined.", show_alert=True)

        # Delete the original callback message
        try:
            await query.message.delete()
        except Exception as e:
            print(f"Failed to delete message: {e}")

        # Send notification about the action taken
        notification_message = await app.send_message(
            SUPPORT_CHAT_ID,
            f"{action} request {status} by {approval_author}.",
        )

        # Delete the notification message after 15 seconds
        await asyncio.sleep(15)
        try:
            await notification_message.delete()
        except Exception as e:
            print(f"Failed to delete notification message: {e}")

    except Exception as e:
        print(f"Unexpected error: {e}")
        await query.answer("An unexpected error occurred. Please try again.", show_alert=True)

async def super_ban_action(user_id, message, approval_author, reason):
    """Perform the super ban action."""
    user = await app.get_users(user_id)
    number_of_chats = 0
    served_chats = [int(chat["chat_id"]) for chat in await get_served_chats()]
    start_time = datetime.utcnow()

    # Super ban in main client
    for chat_id in served_chats:
        if await retry_operation(app.ban_chat_member, chat_id, user_id):
            number_of_chats += 1
        await asyncio.sleep(1)  # Delay to prevent hitting API limits

    # Restarting clients
    logging.info("Restarting all clients for super ban...")
    bots = list(mongo_collection.find())
    for bot in bots:
        string_token = bot['string']
        ai = Client(
            f"{string_token}", API_ID, API_HASH,
            session_string=string_token,
            plugins={"root": "ComboBot.plugins.userbot"},
        )
        await ai.start()
        chats = []
        async for dialog in ai.get_dialogs():
            chats.append(int(dialog.chat.id))
        for chat_id in chats:
            if await retry_operation(ai.ban_chat_member, chat_id, user.id):
                number_of_chats += 1
            await asyncio.sleep(1)  # Delay to prevent hitting API limits
        await ai.send_message(SUPPORT_CHAT_ID, f"Super banned from {number_of_chats} chats.")

    end_time = datetime.utcnow()
    time_taken = end_time - start_time

    final_message = f"""#ɴᴇᴡ_ᴜꜱᴇʀ_sᴜᴘᴇʀʙᴀɴ

sᴜᴘᴇʀ ʙᴀɴ ɪꜱ ᴄᴏᴍᴘʟᴇᴛᴇᴅ.

ᴜꜱᴇʀ : {user.first_name}
ᴜꜱᴇʀ ɪᴅ : {user.id}

ʀᴇᴀꜱᴏɴ : {reason}

ᴍᴀɴᴀɢᴇᴅ ʙʏ : {message.from_user.first_name}
ᴀᴘᴘʀᴏᴠᴇᴅ ʙʏ : {approval_author}

sᴜᴘᴇʀʙᴀɴɴᴇᴅ ᴄʜᴀᴛꜱ : {number_of_chats}

ᴛɪᴍᴇ ᴛᴀᴋᴇɴ : {get_readable_time(time_taken)}

ᴜɴɪᴠᴇʀꜱᴀʟ ᴛɪᴍᴇ : {end_time.strftime('%Y-%m-%d %H:%M:%S')}

ꜱᴜᴘᴘᴏʀᴛ ɢʀᴏᴜᴘ : @TeamArona

ᴘᴏᴡᴇʀᴇᴅ ʙʏ : @AronaYbot"""

    await app.send_message(SUPPORT_CHANNEL_ID, final_message)
    await add_banned_user(user.id)

async def super_unban_action(user_id, message, approval_author, reason):
    """Perform the super unban action."""
    user = await app.get_users(user_id)
    number_of_chats = 0
    served_chats = [int(chat["chat_id"]) for chat in await get_served_chats()]
    start_time = datetime.utcnow()

    # Super unban in main client
    for chat_id in served_chats:
        if await retry_operation(app.unban_chat_member, chat_id, user_id):
            number_of_chats += 1
        await asyncio.sleep(1)  # Delay to prevent hitting API limits

    # Restarting clients
    logging.info("Restarting all clients for super unban...")
    bots = list(mongo_collection.find())
    for bot in bots:
        string_token = bot['string']
        ai = Client(
            f"{string_token}", API_ID, API_HASH,
            session_string=string_token,
            plugins={"root": "ComboBot.plugins.userbot"},
        )
        await ai.start()
        chats = []
        async for dialog in ai.get_dialogs():
            chats.append(int(dialog.chat.id))
        for chat_id in chats:
            if await retry_operation(ai.unban_chat_member, chat_id, user.id):
                number_of_chats += 1
            await asyncio.sleep(1)  # Delay to prevent hitting API limits
        await ai.send_message(SUPPORT_CHAT_ID, f"Super unbanned from {number_of_chats} chats.")

    end_time = datetime.utcnow()
    time_taken = end_time - start_time

    final_message = f"""#ɴᴇᴡ_ᴜꜱᴇʀ_sᴜᴘᴇʀᴜɴʙᴀɴ

sᴜᴘᴇʀ ᴜɴʙᴀɴ ɪꜱ ᴄᴏᴍᴘʟᴇᴛᴇᴅ.

ᴜꜱᴇʀ : {user.first_name}
ᴜꜱᴇʀ ɪᴅ : {user.id}

ʀᴇᴀꜱᴏɴ : {reason}

ᴍᴀɴᴀɢᴇᴅ ʙʏ : {message.from_user.first_name}
ᴀᴘᴘʀᴏᴠᴇᴅ ʙʏ : {approval_author}

sᴜᴘᴇʀᴜɴʙᴀɴɴᴇᴅ ᴄʜᴀᴛꜱ : {number_of_chats}

ᴛɪᴍᴇ ᴛᴀᴋᴇɴ : {get_readable_time(time_taken)}

ᴜɴɪᴠᴇʀꜱᴀʟ ᴛɪᴍᴇ : {end_time.strftime('%Y-%m-%d %H:%M:%S')}

ꜱᴜᴘᴘᴏʀᴛ ɢʀᴏᴜᴘ : @TeamArona

ᴘᴏᴡᴇʀᴇᴅ ʙʏ : @AronaYbot"""

    await app.send_message(SUPPORT_CHANNEL_ID, final_message)
    await remove_banned_user(user.id)

async def get_served_chats():
    """Retrieve the list of served chats from the database."""
    return await mongo_collection.find({}).to_list(length=None)

async def add_banned_user(user_id):
    """Add a user to the banned users list in the database."""
    await mongo_collection.update_one({"user_id": user_id}, {"$set": {"banned": True}}, upsert=True)

async def remove_banned_user(user_id):
    """Remove a user from the banned users list in the database."""
    await mongo_collection.update_one({"user_id": user_id}, {"$set": {"banned": False}})

async def retry_operation(func, *args, retries=3):
    """Retry a function call with specified retries."""
    for attempt in range(retries):
        try:
            return await func(*args)
        except Exception as e:
            if attempt < retries - 1:
                await asyncio.sleep(1)  # Delay before retrying
            else:
                print(f"Operation failed: {e}")
                return False